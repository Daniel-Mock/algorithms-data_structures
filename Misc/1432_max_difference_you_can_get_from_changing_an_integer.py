###########################################################################
#                                                                         #
# Author: Daniel Mock                                                     #
#                                                                         #
# Purpose: To document progress in learning algorithms & data structures  #
#                                                                         #
# References: This question was generated by leetcode.com. The solution   #
# to the question was generated by Daniel Mock.                           #
#                                                                         #
###########################################################################

'''
Overall approach:
* Convert int to list of ints
* Create 2 new lists of ints, 1 for the max possible number and 1 for the min possible number
* Convert the new max/min lists of ints to ints
* Subtract min from max

First, on both passes, you want to change the most significant digit and its
corresponding occurances throughout the number to 9 or 1 in high/low pass,
respecively.
If the first digit IS 9 or 1, you want to reference the 2nd digit!. If THIS digit is 9 or 1,
you want to keep iterating over the number until you reach one that IS NOT 9 or 1
to use as a reference. If you do not find another 9 or 1, you know you have all 9's or 1's,
so handle that case accordingly (do nothing).

Special case: you have a number starting with  1[0-1]+. You know that you can't change 1
to 0 because you can't have a leading 0, and you dont want to reference 0 because its
already 0, so add the check for 0 into the logic when your number starts with 1.
Permutations:
[9.....]
[1.....]
[[2-8].....]
[1[0-1]+...]
'''
class Solution:
    def maxDiff(self, num: int) -> int:
        int_list = [int(i) for i in str(num)]
        x = int_list[0]
        max_list = []
        min_list = []
        if int_list[0] == 9:
            check_high = int_list[:]
            for loc, num in enumerate(check_high):
                if num != 9:
                    break
            x = check_high[loc]

        for digit in int_list:
            if digit == x:
                max_list.append(9)
            else:
                max_list.append(digit)
        y = 1
        x = int_list[0]
        if int_list[0] == 1:
            check_low = int_list[:]
            for loc, num in enumerate(check_low):
                #special check for num = 0, keep iterating until not [0-1]
                if num != 1 and num != 0:
                    break
            x = check_low[loc]
            if x != 1: y = 0
        for digit in int_list:
            if digit == x:
                min_list.append(y)
            else:
                min_list.append(digit)
        max_num = self.magic(max_list)
        min_num = self.magic(min_list)
        return max_num - min_num

    def magic(self, number):
        return int(''.join(str(i) for i in number))
