###########################################################################
#                                                                         #
# Author: Daniel Mock                                                     #
#                                                                         #
# Purpose: To document progress in learning algorithms & data structures  #
#                                                                         #
# References: This question was generated by leetcode.com. The solution   #
# to the question was generated by Daniel Mock.                           #
#                                                                         #
###########################################################################

'''
This file contains several sorting Algorithms.
Included are:
    -Merge sort
    -Insertion sort
    -Quick sort
'''

#Merge Sort Algorithm
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        if len(nums) == 1: return nums
        self.merge_sort(nums)
        return nums

    def merge_sort(self, nums):
        if len(nums) > 1:

            mid = len(nums)//2
            L = nums[:mid]
            R = nums[mid:]
            self.merge_sort(L)
            self.merge_sort(R)

            i = j = k = 0

            while i < len(L) and j < len(R):
                if L[i] < R[j]:
                    nums[k] = L[i]
                    i += 1
                else:
                    nums[k] = R[j]
                    j+=1
                k+=1

            while i < len(L):
                nums[k] = L[i]
                i+=1
                k+=1

            while j < len(R):
                nums[k] = R[j]
                j+=1
                k+=1

'''
#Insertion Sort Algorithm
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        self.nums = nums
        iter = 0
        while iter < len(nums):
            minVal = self.findMin(iter) #min(nums[iter:]), nums.index(min(nums[iter:]))
            minValIndex = self.findPos(minVal, iter)
            nums[iter], nums[minValIndex] = minVal, nums[iter]
            iter+=1
        return nums

    def findMin(self, iter):
        value = self.nums[iter]
        for val in self.nums[iter:]:
            if val < value:
                value = val
        return value

    def findPos(self, minVal, iter):
        for loc, val in enumerate(self.nums):
            if loc >= iter and val == minVal:
                return loc
'''

'''
#Quick Sort Algorithm
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        self.quick_sort(nums, 0, len(nums) - 1)
        return nums

    def quick_sort(self, nums, low, high):
        if low < high:
            pivot_idx = self.partition(nums, low, high)
            self.quick_sort(nums, low, pivot_idx - 1)
            self.quick_sort(nums, pivot_idx + 1, high)

    def partition(self, nums, low, high):
        pivot = nums[high]
        i = low
        for j in range(low, high):
            if nums[j] < pivot:
                nums[i], nums[j] = nums[j], nums[i]
                i += 1
        nums[i], nums[high] = nums[high], nums[i]
        return i
'''
