###########################################################################
#                                                                         #
# Author: Daniel Mock                                                     #
#                                                                         #
# Purpose: To document progress in learning algorithms & data structures  #
#                                                                         #
# References: This question was generated by leetcode.com. The solution   #
# to the question was generated by Daniel Mock.                           #
#                                                                         #
###########################################################################


# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if root is None: return True
        status, height = self.recurse(root, 0)
        return status

    def recurse(self, node, height):
        if node is None:
            return True, height-1
        if node.left is None and node.right is None:
            return True, height

        statusL, left_height = self.recurse(node.left, height+1)
        statusR, right_height = self.recurse(node.right, height+1)

        return (abs(left_height - right_height) <= 1) and statusL and statusR, max(left_height, right_height)





    '''    status, num = self.recurse(root,0)

        return status

    def recurse(self, node, num):
        if node is None:
            return True, num-1
        if node.left is None and node.right is None:
            return True, num

        status1, num1 = self.recurse(node.left, num+1)
        status2, num2 = self.recurse(node.right, num+1)

        return (abs(num1 - num2) <= 1) and status1 and status2, max(num1, num2)
    '''

    '''
    def left_recurse(self, root):
        self.left_val+=1
        if root is None: return
        print("L")
        print(self.left_val, root.val)
        if root.left is None and root.right is None:
            return
        else:
            self.left_recurse(root.left)

    def right_recurse(self, root):
        self.right_val+=1
        if root is None: return
        print("R")
        print(self.right_val, root.val)
        if root.left is None and root.right is None:
            return
        else:
            self.right_recurse(root.left)

    def isBalanced(self, root: TreeNode) -> bool:
        if root is None: return True
        self.left_val = 1
        self.right_val = 1
        if root.left is not None:
            self.left_recurse(root.left)
        if root.right is not None:
            self.right_recurse(root.right)
        print("final L", self.left_val)
        print("final R", self.right_val)
        if abs(self.left_val - self.right_val) > 1: return False
        else: return True
    '''
