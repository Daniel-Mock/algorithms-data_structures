###########################################################################
#                                                                         #
# Author: Daniel Mock                                                     #
#                                                                         #
# Purpose: To document progress in learning algorithms & data structures  #
#                                                                         #
# References: This question was generated by leetcode.com. The solution   #
# to the question was generated by Daniel Mock.                           #
#                                                                         #
###########################################################################


from collections import defaultdict

'''start at each node, do bfs to find # of levels from that node, update map to track num of levels from each node, return list of nodes with least levels'''

#TIME LIMIT EXCEEDED

class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        if n == 1: return [0]
        adj = []

        #initialize adj list with empty lists
        for _ in range(n):
            adj.append([])
        #populate adj list
        for v,u in edges:
            adj[v].append(u)
            adj[u].append(v)

        #create list of leaves
        leaves = []
        for i in range(n):
            if len(adj[i]) == 1:
                leaves.append(i)

        #remove all current leaves and update leaf list

        #if n <= 2, we're at center of list
        while n > 2:
            n -= len(leaves)
            new_leaves = []
            for i in leaves:
                j = adj[i].pop() #remove leaf from one side of connection
                adj[j].remove(i) #remove leaf from other side of connection
                if len(adj[j]) == 1: #if j is now a leaf...
                    new_leaves.append(j)

            #update leaves list
            leaves = new_leaves
        return leaves



        #Solution that did not pass time constraint of leetcode submissions
        '''
        if edges is None: return None
        if n is 1: return [0]
        layers_map = {}
        adj_map = defaultdict(list)

        for i,j in edges:
            adj_map[i].append(j)
            adj_map[j].append(i)

        #print("adj_map: ",adj_map)
        for i in range(len(adj_map)):
            #print("i'th iter: ", i)
            queue = []
            visited = [False] * n
            queue.append(adj_map[i])
            visited[i] = True
            num_layers = self.bfs(queue, layers_map, adj_map, visited)
            layers_map[i] = num_layers
        #print(layers_map)
        temp = min(layers_map.values())
        return [key for key in layers_map if layers_map[key] == temp]

    def bfs(self, queue, layers_map, adj_map, visited):
        num_layers = 1
        #print("queue: ", queue, "layers_map: ", layers_map)
        while len(queue) > 0:
            #print(queue)
            for _ in range(len(queue)):
                node_edges = queue.pop(0)
                for node in node_edges:
                    if not visited[node]:
                        lst2 = []
                        for node2 in adj_map[node]:
                            if not visited[node2]:
                                lst2.append(node2)
                        #print("lst2: ", lst2)
                        if len(lst2) > 0:
                            queue.append(lst2)
                    visited[node] = True
            num_layers+=1
        return num_layers
        '''
