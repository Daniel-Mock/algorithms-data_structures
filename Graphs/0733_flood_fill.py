###########################################################################
#                                                                         #
# Author: Daniel Mock                                                     #
#                                                                         #
# Purpose: To document progress in learning algorithms & data structures  #
#                                                                         #
# References: This question was generated by leetcode.com. The solution   #
# to the question was generated by Daniel Mock.                           #
#                                                                         #
###########################################################################


class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        self.queue = []
        if image[sr][sc] != newColor:
            self.queue = [(sr, sc)]
        ref_color = image[sr][sc]
        self.image = image

        while self.queue:
            for _ in range(len(self.queue)):
                sr_prime, sc_prime = self.queue.pop()
                if  0 <= sr_prime < len(image) and 0 <= sc_prime < len(image[0]) and image[sr_prime][sc_prime] == ref_color:
                    image[sr_prime][sc_prime] = newColor
                    self.add_neighbors(sr_prime, sc_prime)
        return image

    def add_neighbors(self, sr_prime, sc_prime):
        #add neighbors (top, bottom, left, right)
        self.queue.append((sr_prime+1,sc_prime))
        self.queue.append((sr_prime, sc_prime+1))
        self.queue.append((sr_prime-1, sc_prime))
        self.queue.append((sr_prime, sc_prime-1))
