###########################################################################
#                                                                         #
# Author: Daniel Mock                                                     #
#                                                                         #
# Purpose: To document progress in learning algorithms & data structures  #
#                                                                         #
# References: This question was generated by leetcode.com. The solution   #
# to the question was generated by Daniel Mock.                           #
#                                                                         #
###########################################################################



class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        m = max(nums[:k])
        mArr = [m]
        for x in range(k,len(nums)):
            m = max(nums[x],m)
            if nums[x-k] == m:
                m = max(nums[x-k+1:x+1])
            mArr.append(m)
        return mArr

#Too slow solution
'''
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        if not nums: return
        if len(nums) == 1: return nums
        if k == 1:
            return nums

        max_list = []
        start = 0
        end = k
        while end <= len(nums):
            local_max = max(nums[start:end])
            start+=1
            end +=1
            max_list.append(local_max)
        return max_list
'''

#Another solution that's too slow
'''
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        if nums is None: return
        if len(nums) == 1: return nums
        if k == len(nums):
            return [max(nums)]
        current_max = max(nums[0:k])
        output_list = [current_max]
        start_slice = 0
        end_slice = k
        sub_str = nums[start_slice:end_slice]
        while end_slice <= len(nums)-1:
            if current_max == sub_str[0]:
                start_slice+=1
                end_slice+=1
                sub_str = nums[start_slice:end_slice]]
                current_max = max(sub_str)

            else:
                start_slice+=1
                end_slice+=1
                sub_str = nums[start_slice:end_slice]]
                if sub_str[-1] >= current_max:
                    current_max = sub_str[-1]
            output_list.append(current_max)
        return output_list
'''
