###########################################################################
#                                                                         #
# Author: Daniel Mock                                                     #
#                                                                         #
# Purpose: To document progress in learning algorithms & data structures  #
#                                                                         #
# References: This question was generated by leetcode.com. The solution   #
# to the question was generated by Daniel Mock.                           #
#                                                                         #
###########################################################################

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        '''First method uses 1 dictionary. Traverse all of list A, adding each node to the              dictionary. Then, traverse each node of list B and check if that node is in the              dictionary. If so, return the node. If not, repeat the process. If you finish                traversing B list without returning, return None.
        '''
        Alst = {}

        while headA is not None:
            Alst[headA] = headA
            headA = headA.next

        while headB is not None:
            if headB in Alst:
                return headB
            headB = headB.next
        return None
        ########################################################
        '''#create dictionaries to store nodes for each list
        Alst = {}
        Blst = {}

        #traverse each list completely. 'or' is used to cover
        #cases when 1 list is shorter than another
        while headA or headB is not None:

            #insert each node into their respective dictionaries
            Alst[headA] = headA
            Blst[headB] = headB

            #check if node from one list is in the other lists' dictionary.
            #if so, return the node.
            if headA in Blst:
                return headA

            if headB in Alst:
                return headB

            #if you dont find it, move to the next nodes in each list and repeat.
            #try/except is used when 1 list is completed but other is not
            try: headA = headA.next
            except: pass
            try: headB = headB.next
            except: pass

        #if not found in either dictionary, there is not intersection
        return None
        '''   
